\section{Abstrakte Datentypen}
\subsection{}
Wenn eine doppelt verkettete Liste benutzt wird, hat jedes Element einen Vorgänger und einen Nachfolger. Zudem gibt ein head-Element und ein tail-Element. Bei isEmpty muss also nur überprüft werden ob der head leer ist. Dies ist unabhängig von der Länge der Eingabe. Bei den anderen Operationen müssen immer mit die ersten bzw. die letzten beiden Element verändert werden, da man weiß welches Element Vorne bzw. Hinten liegt und  die Nachfolger bzw. Vorgänger bestimmt sind.  durchlaufen werden. Dies hat zur Folge, dass die Länge der Eingabe unabhängig von der Laufzeit ist und somit wie isEmpty in O(1) liegt.
\subsection{}
Die Operationen könne nicht alle in O(1) ausgeführt werden, wenn ein unbeschränktes Array und ein Zeiger zur Hilfe genommen werden. Dies liegt daran, dass bei enqueueBack und daqueueBack das komplette Array durchlaufen werden muss um das letzte Element zu bearbeiten. Somit müssen diese mindestens in O(n) liegen.
\subsection{}
Um herauszufinden ob ein Element e schon in einem Set s vorhanden ist muss im worst-case das gesamte Set durchlaufen werden. Somit sind comtains und add höchstens in O(n). In union muss s2 zu s1 hinzugefügt und s1 ausgegeben werden. Sei $n1$ die Länge von s1 und $n2$ die Länge von s2, so muss um schlimmsten Fall n2 mal n1 durchgelaufen werden, da bei jedem Element aus s2 add benutzt wird um zu sichern, dass kein Element zweimal vorkommt. Somit ist die Laufzeit $n1 \cdot n2$ dies ist $\geq$ $n$ welches $n1+n2$ ist. Da die Laufzeit von union jedoch nur ein Vielfaches von n ist, ist die Laufzeit auch in O(n). \\Damit ist die Aussage bewiesen.
\subsection{}
Es gibt keine Implementierung, sodass die Operation union des ADT Set nur O(1) benötigt. Dies liegt daran, dass für union für jedes Element aus dem einem Set überprüft werden muss ob es schon in dem anderen Set vorkommt. Somit muss jedes mal max das andere Set durchgelaufen werden. Damit ist die Laufzeit von der Eingabelänge abhängig und kann nicht konstant sein.s